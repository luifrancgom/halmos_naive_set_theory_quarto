<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.24">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>16&nbsp; Zorn’s Lemma – Naive Set Theory</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./chapter_15.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js" type="module"></script>
<script src="site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-dc55a5b9e770e841cd82e46aadbfb9b0.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-889171f6e2265cf69758186834c2a0b0.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<!-- ==============================
     Math (MathJax)
     ============================== -->
<script>
  window.MathJax = {
    // Load the TeX 'mathtools' extension for MathJax
    loader: { load: ['[tex]/mathtools'] },
    // Add 'mathtools' to the default TeX package list
    tex: { packages: { '[+]': ['mathtools'] } }
  };
</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-sidebar floating fullcontent quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./chapter_16.html"><span class="chapter-number">16</span>&nbsp; <span class="chapter-title">Zorn’s Lemma</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header sidebar-header-stacked">
      <a href="./index.html" class="sidebar-logo-link">
      </a>
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Naive Set Theory</a> 
        <div class="sidebar-tools-main">
    <a href="https://github.com/luifrancgom/halmos_naive_set_theory_quarto/" title="Source Code" class="quarto-navigation-tool px-1" aria-label="Source Code"><i class="bi bi-github"></i></a>
    <a href="./Naive-Set-Theory.pdf" title="Download PDF" class="quarto-navigation-tool px-1" aria-label="Download PDF"><i class="bi bi-file-pdf"></i></a>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Preface by the Editor</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./preface.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Preface by the Author</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./chapter_1.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">The Axiom of Extension</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./chapter_2.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">The Axiom of Specification</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./chapter_3.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Unordered Pairs</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./chapter_4.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Unions and Intersections</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./chapter_5.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Complements and Powers</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./chapter_6.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Ordered Pairs</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./chapter_7.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Relations</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./chapter_8.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Functions</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./chapter_9.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Families</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./chapter_10.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">Inverses and Composites</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./chapter_11.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">Numbers</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./chapter_12.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">12</span>&nbsp; <span class="chapter-title">The Peano Axioms</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./chapter_13.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">13</span>&nbsp; <span class="chapter-title">Arithmetic</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./chapter_14.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">14</span>&nbsp; <span class="chapter-title">Order</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./chapter_15.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">15</span>&nbsp; <span class="chapter-title">The Axiom Of Choice</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./chapter_16.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">16</span>&nbsp; <span class="chapter-title">Zorn’s Lemma</span></span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span class="chapter-number">16</span>&nbsp; <span class="chapter-title">Zorn’s Lemma</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>An existence theorem asserts the existence of an object belonging to a certain set and possessing certain properties. Many existence theorems can be formulated (or, if need be, reformulated) so that the underlying set is a partially ordered set and the crucial property is maximality. Our next purpose is to state and prove the most important theorem of this kind.</p>
<div id="lem-zorn" class="theorem lemma">
<p><span class="theorem-title"><strong>Lemma 16.1 (Zorn’s lemma)</strong></span> If <span class="math inline">\(X\)</span> is a partially ordered set such that every chain in <span class="math inline">\(X\)</span> has an upper bound, then <span class="math inline">\(X\)</span> contains a maximal element.</p>
</div>
<p><span class="smallcaps">Discussion</span>. Recall that a chain is a totally ordered set. By a chain “in <span class="math inline">\(X\)</span>” we mean a subset of <span class="math inline">\(X\)</span> such that the subset, considered as a partially ordered set on its own right, turns out to be totally ordered. If <span class="math inline">\(A\)</span> is a chain in <span class="math inline">\(X\)</span>, the hypothesis of Zorn’s lemma guarantees the existence of an upper bound for <span class="math inline">\(A\)</span> in <span class="math inline">\(X\)</span>; it does not guarantee the existence of an upper bound for <span class="math inline">\(A\)</span> in <span class="math inline">\(A\)</span>. The conclusion of Zorn’s lemma is the existence of an element <span class="math inline">\(a\)</span> in <span class="math inline">\(X\)</span> with the property that if <span class="math inline">\(a \le x\)</span>, then necessarily <span class="math inline">\(a = x\)</span>.</p>
<p>The basic idea of the proof is similar to the one used in our preceding discussion of infinite sets. Since, by hypothesis, <span class="math inline">\(X\)</span> is not empty, it has an element, say <span class="math inline">\(x_{0}\)</span>. If <span class="math inline">\(x_{0}\)</span> is maximal, stop here. If it is not, then there exists an element, say <span class="math inline">\(x_{1}\)</span>, strictly greater than <span class="math inline">\(x_{0}\)</span>. If <span class="math inline">\(x_{1}\)</span> is maximal, stop here; otherwise continue. Repeat this argument ad infinitum; ultimately it must lead to a maximal element.</p>
<p>The last sentence is probably the least convincing part of the argument; it hides a multitude of difficulties. Observe, for instance, the following possibility. It could happen that the argument, repeated ad infinitum, leads to a whole infinite sequence of non-maximal elements; what are we to do in that case? The answer is that the range of such an infinite sequence is a chain in <span class="math inline">\(X\)</span>, and, consequently, has an upper bound; the thing to do is to start the whole argument all over again, beginning with that upper bound. Just exactly when and how all this comes to an end is obscure, to say the least. There is no help for it; we must look at the precise proof. The structure of the proof is an adaptation of one originally given by Zermelo.</p>
<div class="proof">
<p><span class="proof-title"><em>Proof</em>. </span>The first step is to replace the abstract partial ordering by the inclusion order in a suitable collection of sets. More precisely, we consider, for each element <span class="math inline">\(x\)</span> in <span class="math inline">\(X\)</span>, the weak initial segment <span class="math inline">\(\bar{s}(x)\)</span> consisting of <span class="math inline">\(x\)</span> and all its predecessors. The range <span class="math inline">\(\mathcal{S}\)</span> of the function <span class="math inline">\(\bar{s}\)</span> (from <span class="math inline">\(X\)</span> to <span class="math inline">\(\mathcal{P}(X)\)</span>) is a certain collection of subsets of <span class="math inline">\(X\)</span>, which we may, of course, regard as (partially) ordered by inclusion. The function <span class="math inline">\(\bar{s}\)</span> is one-to-one, and a necessary and sufficient condition that <span class="math inline">\(\bar{s}(x) \subset \bar{s}(y)\)</span> is that <span class="math inline">\(x \le y\)</span>. In view of this, the task of finding a maximal element in <span class="math inline">\(X\)</span> is the same as the task of finding a maximal set in <span class="math inline">\(\mathcal{S}\)</span>. The hypothesis about chains in <span class="math inline">\(X\)</span> implies (and is, in fact, equivalent to) the corresponding statement about chains in <span class="math inline">\(\mathcal{S}\)</span>.</p>
<p>Let <span class="math inline">\(\mathcal{X}\)</span> be the set of all chains in <span class="math inline">\(X\)</span>; every member of <span class="math inline">\(\mathcal{X}\)</span> is included in <span class="math inline">\(\bar{s}(x)\)</span> for some <span class="math inline">\(x\)</span> in <span class="math inline">\(X\)</span>. The collection <span class="math inline">\(\mathcal{X}\)</span> is a non-empty collection of sets, partially ordered by inclusion, and such that if <span class="math inline">\(\mathcal{C}\)</span> is a chain in <span class="math inline">\(\mathcal{X}\)</span>, then the union of the sets in <span class="math inline">\(\mathcal{C}\)</span> (i.e., <span class="math inline">\(\bigcup_{A \in \mathcal{C}} A\)</span>) belongs to <span class="math inline">\(\mathcal{X}\)</span>. Since each set in <span class="math inline">\(\mathcal{X}\)</span> is dominated by some set in <span class="math inline">\(\mathcal{S}\)</span>, the passage from <span class="math inline">\(\mathcal{S}\)</span> to <span class="math inline">\(\mathcal{X}\)</span> cannot introduce any new maximal elements. One advantage of the collection <span class="math inline">\(\mathcal{X}\)</span> is the slightly more specific form that the chain hypothesis assumes; instead of saying at each chain <span class="math inline">\(\mathcal{C}\)</span> has some upper bound in <span class="math inline">\(\mathcal{S}\)</span>, we can say explicitly that the union of the sets of <span class="math inline">\(\mathcal{C}\)</span>, which is clearly an upper bound of <span class="math inline">\(\mathcal{C}\)</span>, is an element of the collection <span class="math inline">\(\mathcal{X}\)</span>. Another technical advantage of <span class="math inline">\(\mathcal{X}\)</span> is that it contains all the subsets of each of its sets; this makes it possible to enlarge non-maximal sets in <span class="math inline">\(\mathcal{X}\)</span> slowly, one element at a time.</p>
<p>Now we can forget about the given partial order in <span class="math inline">\(X\)</span>. In what follows we consider a non-empty collection <span class="math inline">\(\mathcal{X}\)</span> of subsets of a non-empty set <span class="math inline">\(X\)</span>, subject to two conditions: every subset of each set in <span class="math inline">\(\mathcal{X}\)</span> is in <span class="math inline">\(\mathcal{X}\)</span>, and the union of each chain of sets in <span class="math inline">\(\mathcal{X}\)</span> is in <span class="math inline">\(\mathcal{X}\)</span>. Note that the first condition implies that <span class="math inline">\(\emptyset \in \mathcal{X}\)</span>. Our task is to prove that there exists in <span class="math inline">\(\mathcal{X}\)</span> a maximal set.</p>
<p>Let <span class="math inline">\(f\)</span> be a choice function for <span class="math inline">\(X\)</span>, that is, <span class="math inline">\(f\)</span> is a function from the collection of all non-empty subsets of <span class="math inline">\(X\)</span> to <span class="math inline">\(X\)</span> such that <span class="math inline">\(f(A) \in A\)</span> for all <span class="math inline">\(A\)</span> in the domain of <span class="math inline">\(f\)</span>. For each set <span class="math inline">\(A\)</span> in <span class="math inline">\(\mathcal{X}\)</span>, let <span class="math inline">\(\hat{A}\)</span> be the set of all those elements <span class="math inline">\(x\)</span> of <span class="math inline">\(X\)</span> whose adjunction to <span class="math inline">\(A\)</span> produces a set in <span class="math inline">\(\mathcal{X}\)</span>; in other words, <span class="math inline">\(\hat{A} =\{ x \in X:A \cup \{ x \} \in \mathcal{X} \}\)</span>. Define a function <span class="math inline">\(g\)</span> from <span class="math inline">\(\mathcal{X}\)</span> to <span class="math inline">\(\mathcal{X}\)</span> as follows: if <span class="math inline">\(\hat{A} - A \neq \emptyset\)</span>, then <span class="math inline">\(g(A) = A \cup \{ f( \hat{A} - A) \}\)</span>; if <span class="math inline">\(\hat{A} - A = \emptyset\)</span>, then <span class="math inline">\(g(A) = A\)</span>. It follows from the definition of <span class="math inline">\(\hat{A}\)</span> that <span class="math inline">\(\hat{A} - A = \emptyset\)</span> if and only if <span class="math inline">\(A\)</span> is maximal. In these terms, therefore, what we must prove is that there exists in <span class="math inline">\(\mathcal{X}\)</span> a set <span class="math inline">\(A\)</span> such that <span class="math inline">\(g(A) = A\)</span>. It turns out that the crucial property of <span class="math inline">\(g\)</span> is the fact that <span class="math inline">\(g(A)\)</span> (which always includes <span class="math inline">\(A\)</span>) contains at most one more element than <span class="math inline">\(A\)</span>.</p>
<p>Now, to facilitate the exposition, we introduce a temporary definition. We shall say that a subcollection <span class="math inline">\(\mathcal{J}\)</span> of <span class="math inline">\(\mathcal{X}\)</span> is a <em>tower</em> if</p>
<p><span class="math display">\[\begin{align*}
&amp;(i) \: \emptyset \in \mathcal{J}, \\
&amp;(ii) \mathit{\ if\ } A \in \mathcal{J}, \mathit{\ then\ } g(A) \in \mathcal{J} ,\\
&amp;(iii) \mathit{\ if\ } \mathcal{C} \mathit{\ is\ a\ chain\ in\ } \mathcal{J}, \mathit{\ then\ } \bigcup_{A \in \mathcal{C}} A \in \mathcal{J}.
\end{align*}\]</span></p>
<p>Towers surely exist; the whole collection <span class="math inline">\(\mathcal{X}\)</span> is one. Since the intersection of a collection of towers is again a tower, it follows, in particular, that if <span class="math inline">\(\mathcal{J}_{0}\)</span> is the intersection of all towers, then <span class="math inline">\(\mathcal{J}_{0}\)</span> is the smallest tower. Our immediate purpose is to prove that the tower <span class="math inline">\(\mathcal{J}_{0}\)</span> is a chain.</p>
<p>Let us say that a set <span class="math inline">\(C\)</span> in <span class="math inline">\(\mathcal{J}_{0}\)</span> is <em>comparable</em> if it is comparable with every set in <span class="math inline">\(\mathcal{J}_{0}\)</span>; this means that if <span class="math inline">\(A \in \mathcal{J}_{0}\)</span>, then either <span class="math inline">\(A \subset C\)</span> or <span class="math inline">\(C \subset A\)</span>. To say that <span class="math inline">\(\mathcal{J}_{0}\)</span> is a chain means that all the sets in <span class="math inline">\(\mathcal{J}_{0}\)</span> are comparable. Comparable sets surely exist: <span class="math inline">\(\emptyset\)</span> is one of them. In the next couple of paragraphs we concentrate our attention on an arbitrary but temporarily fixed comparable set <span class="math inline">\(C\)</span>.</p>
<p>Suppose that <span class="math inline">\(A \in \mathcal{J}_{0}\)</span> and <span class="math inline">\(A\)</span> is a proper subset of <span class="math inline">\(C\)</span>. Assertion: <span class="math inline">\(g(A) \subset C\)</span>. The reason is that since <span class="math inline">\(C\)</span> is comparable, either <span class="math inline">\(g(A) \subset C\)</span> or <span class="math inline">\(C\)</span> is a proper subset of <span class="math inline">\(g(A)\)</span>. In the latter case <span class="math inline">\(A\)</span> is a proper subset of a proper subset of <span class="math inline">\(g(A)\)</span>, and this contradicts the fact that <span class="math inline">\(g(A) - A\)</span> cannot be more than a singleton.</p>
<p>Consider next the collection <span class="math inline">\(\mathcal{U}\)</span> of all those sets <span class="math inline">\(A\)</span> in <span class="math inline">\(\mathcal{J}_{0}\)</span> for which either <span class="math inline">\(A \subset C\)</span> or <span class="math inline">\(g(C) \subset A\)</span>. The collection <span class="math inline">\(\mathcal{U}\)</span> is somewhat smaller than the collection of sets in <span class="math inline">\(\mathcal{J}_{0}\)</span> comparable with <span class="math inline">\(g(C)\)</span>; indeed if <span class="math inline">\(A \in \mathcal{U}\)</span>, then, since <span class="math inline">\(C \subset g(C)\)</span>, either <span class="math inline">\(A \subset g(C)\)</span> or <span class="math inline">\(g(C) \subset A\)</span>. Assertion: <span class="math inline">\(\mathcal{U}\)</span> is a tower. Since <span class="math inline">\(\emptyset \subset C\)</span>, the first condition on towers is satisfied. To prove the second condition, i.e., that if <span class="math inline">\(A \in \mathcal{U}\)</span>, then <span class="math inline">\(g(A) \in \mathcal {U}\)</span>, split the discussion into three cases. First: <span class="math inline">\(A\)</span> is a proper subset of <span class="math inline">\(C\)</span>. Then <span class="math inline">\(g(A) \subset C\)</span> by the preceding paragraph, and therefore <span class="math inline">\(g(A) \in \mathcal{U}\)</span>. Second: <span class="math inline">\(A = C\)</span>. Then <span class="math inline">\(g(A) = g(C)\)</span>, so that <span class="math inline">\(g(C) \subset g(A)\)</span>, and therefore <span class="math inline">\(g(A) \in \mathcal{U}\)</span>. Third: <span class="math inline">\(g(C) \subset A\)</span>. Then <span class="math inline">\(g(C) \subset g(A)\)</span>, and therefore <span class="math inline">\(g(A) \in \mathcal{U}\)</span>. The third condition on towers, i.e., that the union of a chain in <span class="math inline">\(\mathcal{U}\)</span> belongs to <span class="math inline">\(\mathcal{U}\)</span>, is immediate from the definition of <span class="math inline">\(\mathcal{U}\)</span>. Conclusion: <span class="math inline">\(\mathcal{U}\)</span> is a tower included in <span class="math inline">\(\mathcal{J}_{0}\)</span>, and therefore, since <span class="math inline">\(\mathcal{J}_{0}\)</span> is the smallest tower, <span class="math inline">\(\mathcal{U} = \mathcal{J}_{0}\)</span>.</p>
<p>The preceding considerations imply that for each comparable set <span class="math inline">\(C\)</span> the set <span class="math inline">\(g(C)\)</span> is comparable also. Reason: given <span class="math inline">\(C\)</span>, form <span class="math inline">\(\mathcal{U}\)</span> as above; the fact that <span class="math inline">\(\mathcal{U} = \mathcal{J}_{0}\)</span> means that if <span class="math inline">\(A \in \mathcal{J}_{0}\)</span>, then either <span class="math inline">\(A \subset C\)</span> (in which case <span class="math inline">\(A \subset g(C)\)</span>) or <span class="math inline">\(g(C) \subset A\)</span>.</p>
<p>We now know that <span class="math inline">\(\emptyset\)</span> is comparable and that <span class="math inline">\(g\)</span> maps comparable sets onto comparable sets. Since the union of a chain of comparable sets is comparable, it follows that the comparable sets (in <span class="math inline">\(\mathcal{J}_{0}\)</span>) constitute a tower, and hence that they exhaust <span class="math inline">\(\mathcal{J}_{0}\)</span>; this is what we set out to prove about <span class="math inline">\(\mathcal{J}_{0}\)</span>.</p>
<p>Since <span class="math inline">\(\mathcal{J}_{0}\)</span> is a chain, the union, say <span class="math inline">\(A\)</span>, of all the sets in <span class="math inline">\(\mathcal{J}_{0}\)</span> is itself a set in <span class="math inline">\(\mathcal{J}_{0}\)</span>. Since the union includes all the sets in <span class="math inline">\(\mathcal{J}_{0}\)</span>, it follows that <span class="math inline">\(g(A) \subset A\)</span>. Since always <span class="math inline">\(A \subset g(A)\)</span>, it follows that <span class="math inline">\(A = g(A)\)</span>, and the proof of Zorn’lemma is complete.</p>
</div>
<div id="exr-16-1" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 16.1</strong></span> Zorn’s lemma is equivalent to the axiom of choice. [Hint for the proof: given a set <span class="math inline">\(X\)</span>, consider functions <span class="math inline">\(f\)</span> such that <span class="math inline">\(\text{dom } f \subset \mathcal{P}(X)\)</span>, <span class="math inline">\(\text{ran } f \subset X\)</span>, and <span class="math inline">\(f(A) \in A\)</span> for all <span class="math inline">\(A\)</span> in <span class="math inline">\(\text{dom } f\)</span>; order these functions by extension, use Zorn’s lemma to find a maximal one among them, and prove that if <span class="math inline">\(f\)</span> is maximal, then <span class="math inline">\(\text{dom } f = \mathcal{P}(X) - \{ \emptyset \}\)</span>.] Consider each of the following statements and prove that they too are equivalent to the axiom of choice. (i) Every partially ordered set has a maximal chain (i.e., a chain that is not a proper subset of any other chain). (ii) Every chain in a partially ordered set is included in some maximal chain. (iii) Every partially ordered set in which each chain has a least upper bound has a maximal element.</p>
</div>



</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./chapter_15.html" class="pagination-link" aria-label="The Axiom Of Choice">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">15</span>&nbsp; <span class="chapter-title">The Axiom Of Choice</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
  </div>
</nav>
</div> <!-- /content -->




<footer class="footer"><div class="nav-footer"><div class="nav-footer-center"><div class="toc-actions"><ul><li><a href="https://github.com/luifrancgom/halmos_naive_set_theory_quarto/edit/main/chapter_16.qmd" class="toc-action"><i class="bi bi-github"></i>Edit this page</a></li><li><a href="https://github.com/luifrancgom/halmos_naive_set_theory_quarto/blob/main/chapter_16.qmd" class="toc-action"><i class="bi empty"></i>View source</a></li><li><a href="https://github.com/luifrancgom/halmos_naive_set_theory_quarto/issues/new" class="toc-action"><i class="bi empty"></i>Report an issue</a></li></ul></div></div></div></footer></body></html>