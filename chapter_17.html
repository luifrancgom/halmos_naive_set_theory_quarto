<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.25">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>17&nbsp; Well Ordering – Naive Set Theory</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./chapter_16.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js" type="module"></script>
<script src="site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-7b89279ff1a6dce999919e0e67d4d9ec.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-889171f6e2265cf69758186834c2a0b0.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<!-- ==============================
     Math (MathJax)
     ============================== -->
<script>
  window.MathJax = {
    // Load the TeX 'mathtools' extension for MathJax
    loader: { load: ['[tex]/mathtools'] },
    // Add 'mathtools' to the default TeX package list
    tex: { packages: { '[+]': ['mathtools'] } }
  };
</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-sidebar floating fullcontent quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./chapter_17.html"><span class="chapter-number">17</span>&nbsp; <span class="chapter-title">Well Ordering</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header sidebar-header-stacked">
      <a href="./index.html" class="sidebar-logo-link">
      </a>
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Naive Set Theory</a> 
        <div class="sidebar-tools-main">
    <a href="https://github.com/luifrancgom/halmos_naive_set_theory_quarto/" title="Source Code" class="quarto-navigation-tool px-1" aria-label="Source Code"><i class="bi bi-github"></i></a>
    <a href="./Naive-Set-Theory.pdf" title="Download PDF" class="quarto-navigation-tool px-1" aria-label="Download PDF"><i class="bi bi-file-pdf"></i></a>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Preface by the Editor</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./preface.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Preface by the Author</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./chapter_1.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">The Axiom of Extension</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./chapter_2.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">The Axiom of Specification</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./chapter_3.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Unordered Pairs</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./chapter_4.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Unions and Intersections</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./chapter_5.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Complements and Powers</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./chapter_6.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Ordered Pairs</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./chapter_7.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Relations</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./chapter_8.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Functions</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./chapter_9.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Families</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./chapter_10.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">Inverses and Composites</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./chapter_11.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">Numbers</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./chapter_12.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">12</span>&nbsp; <span class="chapter-title">The Peano Axioms</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./chapter_13.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">13</span>&nbsp; <span class="chapter-title">Arithmetic</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./chapter_14.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">14</span>&nbsp; <span class="chapter-title">Order</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./chapter_15.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">15</span>&nbsp; <span class="chapter-title">The Axiom Of Choice</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./chapter_16.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">16</span>&nbsp; <span class="chapter-title">Zorn’s Lemma</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./chapter_17.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">17</span>&nbsp; <span class="chapter-title">Well Ordering</span></span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span class="chapter-number">17</span>&nbsp; <span class="chapter-title">Well Ordering</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>A partially ordered may not have a smallest element, and, even if it has one, it is perfectly possible that some subset will fail to have one. A partially ordered set is called <em>well ordered</em> (and its ordering is called a <em>well ordering</em>) if every non-empty subset of it has a smallest element. One consequence of this definition, worth noting even before we look at any examples and counterexamples, is that every well ordered set is totally ordered. Indeed, if <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> are elements of a well ordered set, then <span class="math inline">\(\{ x,y \}\)</span> is a non-empty subset of that well ordered set and has therefore a first element; according as that first element is <span class="math inline">\(x\)</span> or <span class="math inline">\(y\)</span>, we have <span class="math inline">\(x \le y\)</span> or <span class="math inline">\(y \le x\)</span>.</p>
<p>For each natural number <span class="math inline">\(n\)</span>, the set of all predecessors of <span class="math inline">\(n\)</span> (that is, in accordance with our definitions, the set <span class="math inline">\(n\)</span>) is a well ordered set (ordered by magnitude), and the same is true of the set <span class="math inline">\(\omega\)</span> of all natural numbers. The set <span class="math inline">\(\omega \times \omega\)</span>, with <span class="math inline">\((a,b) \le (x,y)\)</span> defined to mean <span class="math inline">\((2a + 1)2^{y} \le (2x + 1)2^{b}\)</span> is not well ordered. One way to see this is to note that <span class="math inline">\((a,b + 1) \le (a,b)\)</span> for all <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span>; it follows that the entire set <span class="math inline">\(\omega \times \omega\)</span> has no least element. Some subsets of <span class="math inline">\(\omega \times \omega\)</span> do have a least element. Consider, for example, the set <span class="math inline">\(E\)</span> of all those pairs <span class="math inline">\((a, b)\)</span> for which <span class="math inline">\((1,1) \le (a,b)\)</span>; the set <span class="math inline">\(E\)</span> has <span class="math inline">\((1, 1)\)</span> for its least element. Caution: <span class="math inline">\(E\)</span>, considered as a partially ordered set on its own right, is still not well ordered. The trouble is that even though <span class="math inline">\(E\)</span> has a least element, many subsets of <span class="math inline">\(E\)</span> fail to have one; for an example consider the set of all those pairs <span class="math inline">\((a,b)\)</span> in <span class="math inline">\(E\)</span> for which <span class="math inline">\((a,b) \neq (1, 1)\)</span>. One more example: <span class="math inline">\(\omega \times \omega\)</span> is well ordered by its lexicographical ordering.</p>
<p>One of the pleasantest facts about well ordered sets is that we can prove things about their elements by process similar to mathematical induction. Precisely speaking, suppose that <span class="math inline">\(S\)</span> is a subset of a well ordered set <span class="math inline">\(X\)</span>, and suppose that whenever an element <span class="math inline">\(x\)</span> of <span class="math inline">\(X\)</span> is such that the entire initial segment <span class="math inline">\(s(x)\)</span> is included in <span class="math inline">\(S\)</span>, then <span class="math inline">\(x\)</span> itself belongs to <span class="math inline">\(S\)</span>; the <strong>principle of transfinite induction</strong> asserts that under these circumstances we must have <span class="math inline">\(S = X\)</span>. Equivalently: if the presence in a set of all the strict predecessors of an element always implies the presence of the element itself, then the set must contain everything.</p>
<p>A few remarks are in order before we look at the proof. The statement of the ordinary principle of mathematical induction differs from that of transfinite induction in two conspicuous respects. One: the latter, instead of passing to each element from its predecessor, passes to each element from the set of all its predecessors. Two: in the latter there is no assumption about a starting element (such as zero). The first difference is important: an element in a well ordered set may fail to have an immediate predecessor. The present statement when applied to <span class="math inline">\(\omega\)</span> is easily proved to be equivalent to the principle of mathematical induction; that principle, however, when applied to an arbitrary well ordered set, is not equivalent to the principle of transfinite induction. To put it differently: the two statements are in general not equivalent to each other; their equivalence in <span class="math inline">\(\omega\)</span> is a happy but special circumstance.</p>
<p>Here is an example. Let <span class="math inline">\(X\)</span> be <span class="math inline">\(\omega^{+}\)</span>, i.e., <span class="math inline">\(X = \omega \cup \{ \omega \}\)</span>. Define order in <span class="math inline">\(X\)</span> by ordering the elements of <span class="math inline">\(\omega\)</span> as usual and by requiring that <span class="math inline">\(n &lt; \omega\)</span> for all <span class="math inline">\(n\)</span> in <span class="math inline">\(\omega\)</span>. The result is a well ordered set. Question: does there exist a proper subset <span class="math inline">\(S\)</span> of <span class="math inline">\(X\)</span> such that <span class="math inline">\(0 \in S\)</span> and such that <span class="math inline">\(n + 1 \in  S\)</span> whenever <span class="math inline">\(n \in S\)</span>? Answer: yes, namely <span class="math inline">\(S = \omega\)</span>.</p>
<p>The second difference between ordinary induction and transfinite induction (no starting element required for the latter) is more linguistic than conceptual. If <span class="math inline">\(x_{0}\)</span> is the smallest element of <span class="math inline">\(X\)</span>, then <span class="math inline">\(s(x_{0})\)</span> is empty, and, consequently, <span class="math inline">\(s(x_{0}) \subset S\)</span>; the hypothesis of the principle of transfinite induction requires therefore that <span class="math inline">\(x_{0}\)</span> belong to <span class="math inline">\(S\)</span>.</p>
<p>The proof of the principle of transfinite induction is almost trivial. If <span class="math inline">\(X - S\)</span> is not empty, then it has a smallest element, say <span class="math inline">\(x\)</span>. This implies that every element of the initial segment <span class="math inline">\(s(x)\)</span> belongs to <span class="math inline">\(S\)</span>, and hence, by the induction hypothesis, that <span class="math inline">\(x\)</span> belongs to <span class="math inline">\(S\)</span>. This is a contradiction (<span class="math inline">\(x\)</span> cannot belong to both <span class="math inline">\(S\)</span> and <span class="math inline">\(X - S\)</span>); the conclusion is that <span class="math inline">\(X - S\)</span> is empty after all.</p>
<p>We shall say that a well ordered set <span class="math inline">\(A\)</span> is a <em>continuation</em> of a well ordered set <span class="math inline">\(B\)</span>, if, in the first place, <span class="math inline">\(B\)</span> is a subset of <span class="math inline">\(A\)</span>, if, in fact, <span class="math inline">\(B\)</span> is an initial segment of <span class="math inline">\(A\)</span>, and if, finally, the ordering of the elements in <span class="math inline">\(B\)</span> is the same as their ordering in <span class="math inline">\(A\)</span>. Thus if <span class="math inline">\(X\)</span> is a well ordered set and if <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> are elements of <span class="math inline">\(X\)</span> with <span class="math inline">\(b &lt; a\)</span>, then <span class="math inline">\(s(a)\)</span> is a continuation of <span class="math inline">\(s(b)\)</span>, and, of course, <span class="math inline">\(X\)</span> is a continuation of both <span class="math inline">\(s(a)\)</span> and <span class="math inline">\(s(b)\)</span>.</p>
<p>If <span class="math inline">\(\mathcal{C}\)</span> is an arbitrary collection of initial segments of a well ordered set, then <span class="math inline">\(\mathcal{C}\)</span> is a chain with respect to continuation; this means that <span class="math inline">\(\mathcal{C}\)</span> is a collection of well ordered sets with the property that of any two distinct members of the collection one is a continuation of the other. A sort of converse of this comment is also true and is frequently useful. If a collection <span class="math inline">\(\mathcal{C}\)</span> of well ordered sets is a chain with respect to continuation, and if <span class="math inline">\(U\)</span> is the union of the sets of <span class="math inline">\(\mathcal{C}\)</span>, then there is a unique well ordering of <span class="math inline">\(U\)</span> such that <span class="math inline">\(U\)</span> is a continuation of each set (distinct from <span class="math inline">\(U\)</span> itself) in the collection <span class="math inline">\(\mathcal{C}\)</span>. Roughly speaking, the union of a chain of well ordered sets is well ordered. This abbreviated formulation is dangerous because it does not explain that “chain” is meant with respect to continuation. If the ordering implied by the word “chain” is taken to be simply order-preserving inclusion, then the conclusion is not valid.</p>
<p>The proof is straightforward. If <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> are in <span class="math inline">\(U\)</span>, then there exist sets <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> in <span class="math inline">\(\mathcal{C}\)</span> with <span class="math inline">\(a \in A\)</span> and <span class="math inline">\(b \in B\)</span>. Since either <span class="math inline">\(A = B\)</span> or one of <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> is a continuation of the other, it follows that in every case both <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> belong to some one set in <span class="math inline">\(\mathcal{C}\)</span>; the order of <span class="math inline">\(U\)</span> is defined by ordering each pair <span class="math inline">\(\{ a,b \}\)</span> the way it is ordered in any set of <span class="math inline">\(\mathcal{C}\)</span> that contains both <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span>. Since <span class="math inline">\(\mathcal{C}\)</span> is a chain, this order is unambiguously determined. (An alternative way of defining the promised order in <span class="math inline">\(U\)</span> is to recall that the given orders, in the sets of <span class="math inline">\(\mathcal{C}\)</span>, are sets of ordered pairs, and to form the union of all those sets of ordered pairs.)</p>
<p>A direct verification shows that the relation defined in the preceding paragraph is indeed an order, and that, moreover, its construction was forced on us at every step (i.e., that the final order is uniquely determined by the given orders). The proof that the result is actually a well ordering is equally direct. Each non-empty subset of <span class="math inline">\(U\)</span> must have non-empty intersection with some set in <span class="math inline">\(\mathcal{C}\)</span>, and hence it must have a first element in that set; the fact that <span class="math inline">\(\mathcal{C}\)</span> is a continuation chain implies that that first element is necessarily the first element of <span class="math inline">\(U\)</span> also.</p>
<div id="exr-17-1" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 17.1</strong></span> A subset <span class="math inline">\(A\)</span> of a partially ordered set <span class="math inline">\(X\)</span> is <em>cofinal</em> in <span class="math inline">\(X\)</span> in case for each element <span class="math inline">\(x\)</span> of <span class="math inline">\(X\)</span> there exists an element <span class="math inline">\(a\)</span> of <span class="math inline">\(A\)</span> such that <span class="math inline">\(x \le a\)</span>. Prove that every totally ordered set has a cofinal well ordered subset.</p>
</div>
<p>The importance of well ordering stems from the following result, from which we may infer, among other things, that the principle of transfinite induction is much more widely applicable than a casual glance might indicate.</p>
<div id="thm-well-ordering" class="theorem">
<p><span class="theorem-title"><strong>Theorem 17.1 (Well ordering theorem)</strong></span> Every set can be well ordered.</p>
</div>
<p><span class="smallcaps">Discussion</span>. A better (but less traditional) statement is this: for each set <span class="math inline">\(X\)</span>, there is a well ordering with domain <span class="math inline">\(X\)</span>. Warning: the well ordering is not promised to have any relation whatsoever to any other structure that the given set might already possess. If, for instance, the reader knows of some partially or totally ordered sets whose ordering is very definitely not a well ordering, he should not jump to the conclusion that he has discovered a paradox. The only conclusion to be drawn is that some sets can be ordered in many ways, some of which are well orderings others are not, and we already knew that.</p>
<div class="proof">
<p><span class="proof-title"><em>Proof</em>. </span>We apply Zorn’s lemma. Given the set <span class="math inline">\(X\)</span>, consider the collection <span class="math inline">\(\mathcal{W}\)</span> of all well ordered subsets of <span class="math inline">\(X\)</span>. Explicitly: an element of <span class="math inline">\(\mathcal{W}\)</span> is a subset <span class="math inline">\(A\)</span> of <span class="math inline">\(X\)</span> together with a well ordering of <span class="math inline">\(A\)</span>. We partially order <span class="math inline">\(\mathcal{W}\)</span> by continuation.</p>
<p>The collection <span class="math inline">\(\mathcal{W}\)</span> is not empty, because, for instance, <span class="math inline">\(\emptyset \in \mathcal{W}\)</span>. If <span class="math inline">\(X \neq \emptyset\)</span>, less annoying elements of <span class="math inline">\(\mathcal{W}\)</span> can be exhibited; one such is <span class="math inline">\(\{ (x,x) \}\)</span>, for any particular element <span class="math inline">\(x\)</span> of <span class="math inline">\(X\)</span>. If <span class="math inline">\(\mathcal{C}\)</span> is a chain in <span class="math inline">\(\mathcal{W}\)</span> then the union <span class="math inline">\(U\)</span> of the sets in <span class="math inline">\(\mathcal{C}\)</span> has a unique well ordering that makes <span class="math inline">\(U\)</span> “larger” than (or equal to) each set in <span class="math inline">\(\mathcal{C}\)</span>; this is exactly what our preceding discussion of continuation has accomplished. This means that the principal hypothesis of Zorn’s lemma has been verified; the conclusion is that there exists a maximal well ordered set, say <span class="math inline">\(M\)</span>, in <span class="math inline">\(\mathcal{W}\)</span>. The set <span class="math inline">\(M\)</span> must be equal to the entire set <span class="math inline">\(X\)</span>. Reason: if <span class="math inline">\(x\)</span> is an element of <span class="math inline">\(X\)</span> not in <span class="math inline">\(M\)</span>, then <span class="math inline">\(M\)</span> can be enlarged by putting <span class="math inline">\(x\)</span> after all the elements of <span class="math inline">\(M\)</span>. The rigorous formulation of this unambiguous but informal description is left as an exercise for the reader. With that out of the way, the proof of the well ordering theorem is complete.</p>
</div>
<div id="exr-17-2" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 17.2</strong></span> Prove that a totally ordered set is well ordered if and only if the set of strict predecessors of each element is well ordered. Does any such condition apply to partially ordered sets? Prove that the well ordering theorem implies the axiom of choice (and hence is equivalent to that axiom and to Zorn’s lemma). Prove that if <span class="math inline">\(R\)</span> is a partial order in a set <span class="math inline">\(X\)</span>, then there exists a total order <span class="math inline">\(S\)</span> in <span class="math inline">\(X\)</span> such that <span class="math inline">\(R \subset S\)</span>; in other words, every partial order can be extended to total a order without enlarging the domain.</p>
</div>



</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./chapter_16.html" class="pagination-link" aria-label="Zorn's Lemma">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">16</span>&nbsp; <span class="chapter-title">Zorn’s Lemma</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
  </div>
</nav>
</div> <!-- /content -->




<footer class="footer"><div class="nav-footer"><div class="nav-footer-center"><div class="toc-actions"><ul><li><a href="https://github.com/luifrancgom/halmos_naive_set_theory_quarto/edit/main/chapter_17.qmd" class="toc-action"><i class="bi bi-github"></i>Edit this page</a></li><li><a href="https://github.com/luifrancgom/halmos_naive_set_theory_quarto/blob/main/chapter_17.qmd" class="toc-action"><i class="bi empty"></i>View source</a></li><li><a href="https://github.com/luifrancgom/halmos_naive_set_theory_quarto/issues/new" class="toc-action"><i class="bi empty"></i>Report an issue</a></li></ul></div></div></div></footer></body></html>